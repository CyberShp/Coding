# C/C++ 代码深度分析方法论 — AI 分析引擎改进规格书

> **本文档的读者是 AI**。你需要根据本文档改进你的代码分析引擎。
> 你的分析引擎会调用其他 AI 对代码做深层分析。
> 本文档定义了"深层分析"到底意味着什么、当前分析浅在哪、应该深到什么程度。
> 项目只涉及 C 和 C++ 代码。

---

## 第一章 核心问题：什么叫"分析太浅"

当前分析本质上在做**单作用域的模式匹配**——看到一个函数里出现了某个操作，就在这个函数的大括号范围内找有没有对应的逆操作。找不到就报问题。

这个思路的根本缺陷：**C/C++ 的语义关系大量跨越函数边界、文件边界、甚至跨越编译时和运行时边界。** 在单个函数内部做模式匹配，等于只看一个房间就试图理解整栋建筑的结构。

### 一个例子说明深浅差距

不要把这个例子当成"锁的问题"——它代表的是一整类问题的缩影：

```c
// device.c
void device_acquire_resource(struct dev *d) {
    // 获取了某个东西（可以是锁、内存、文件句柄、引用计数、任何东西）
    acquire(d->resource);
}

void device_release_resource(struct dev *d) {
    release(d->resource);
}

// caller.c
int do_work(struct dev *d) {
    device_acquire_resource(d);
    int ret = step_one(d);
    if (ret < 0)
        return ret;             // ← 真 bug：错误路径没有走 release
    ret = step_two(d);
    if (ret < 0)
        goto err;               // ← 正确：走了 cleanup
    device_release_resource(d);
    return 0;
err:
    device_release_resource(d);
    return ret;
}
```

**浅层分析**会说：`device_acquire_resource` 里 acquire 了没 release —— 这是**误报**。
**浅层分析**看不到：`do_work` 第一个 `return ret` 跳过了 release —— 这是**漏报**。

浅层分析同时产生了误报和漏报，而真正的 bug 完全没被发现。

---

## 第二章 应该分析什么：完整的语义关系分类

下面每一类都是"跨越单函数边界的语义关系"。当前分析对其中大部分完全没有覆盖。
你在改进分析引擎时，需要**全部覆盖**，而不是只做其中某一类。

每一类我会说明：它是什么、为什么单函数分析抓不到、正确的分析思路是什么。

### 2.1 配对操作的跨函数生命周期

**是什么：** C/C++ 中大量操作是成对出现的——做了 A 就必须做 B。但 A 和 B 经常不在同一个函数。

**不只是锁。** 这是 C/C++ 中最普遍的模式，至少包括：

| A 操作 | B 操作 | 后果 |
|--------|--------|------|
| 申请堆内存 (malloc/new/kmalloc...) | 释放 (free/delete/kfree...) | 内存泄漏 |
| 打开文件/socket (open/fopen/socket...) | 关闭 (close/fclose...) | 句柄泄漏 |
| 获取锁 (mutex_lock/spin_lock...) | 释放锁 (mutex_unlock/spin_unlock...) | 死锁 |
| 增加引用计数 (kref_get/AddRef...) | 减少引用计数 (kref_put/Release...) | 内存泄漏或 use-after-free |
| 映射 DMA/MMIO (dma_map_single/ioremap...) | 解映射 (dma_unmap_single/iounmap...) | 资源泄漏/数据损坏 |
| 使能时钟/电源 (clk_prepare_enable/pm_runtime_get_sync...) | 关闭 (clk_disable_unprepare/pm_runtime_put...) | 功耗异常/硬件状态错误 |
| 启动定时器/工作队列 (mod_timer/queue_work...) | 停止 (del_timer_sync/cancel_work_sync...) | 卸载后回调踩空 |
| 注册设备/中断 (register_chrdev/request_irq...) | 注销 (unregister_chrdev/free_irq...) | 资源泄漏 |
| 禁用中断/抢占 (local_irq_disable/preempt_disable...) | 恢复 (local_irq_enable/preempt_enable...) | 系统挂死 |
| 进入 RCU 读临界区 (rcu_read_lock...) | 退出 (rcu_read_unlock...) | 内核 BUG |

**还包括项目自己封装的配对函数**——名字可以是任何东西。分析引擎不能只认识标准库的函数名，必须能从调用关系中推断出"这两个函数是配对的"。

**正确的分析思路：**

1. 识别所有配对操作（标准的 + 项目自定义的）
2. 追踪 acquire 所在函数的**所有调用者**，找到 release 在哪里被调用
3. 确认配对关系后，检查每个**调用者的每条执行路径**（包括所有 if 分支、goto 分支、return 点）是否都经过了 release
4. 已确认配对的操作不要误报为"没有释放"

### 2.2 错误路径的完整性

**是什么：** 一个函数按顺序获取了资源 A → B → C，如果 C 失败了，需要按 C → B → A 的顺序释放。如果 B 失败了，只需要释放 A。Linux 内核的 goto 阶梯模式就是为此设计的。

**为什么难抓：** 需要理解 goto label 到底清理了哪些资源、每个 goto 跳转点处到底已经持有了哪些资源。

**正确的分析思路：**

1. 在一个函数内，按代码顺序列出所有资源获取点
2. 在每个可能的错误退出点（goto label、early return），列出此时**已经获取但还没释放**的资源
3. 检查该退出点之后的清理代码是否释放了上述所有资源
4. 典型 bug 模式：函数中间新增了一个资源获取，但 goto 的目标 label 是旧的，没有覆盖新资源

### 2.3 回调函数的执行上下文约束

**是什么：** C 没有语言级别的 async/await 标记。一个函数是在"普通进程上下文"执行还是在"中断上下文"执行，完全取决于它被谁调用——而这个调用关系经常是通过函数指针间接建立的。

**常见的约束关系：**

- 中断处理函数、定时器回调、tasklet 回调：运行在**原子上下文**，**不能做任何可能睡眠的操作**
- 可能睡眠的操作包括但不限于：获取 mutex、用 GFP_KERNEL 分配内存、copy_from_user/copy_to_user、msleep/schedule 等
- 工作队列回调：运行在进程上下文，可以睡眠
- probe/remove 回调：运行在进程上下文

**正确的分析思路：**

1. 找到所有通过函数指针赋值建立的回调关系（`.handler = my_func`、`request_irq(irq, my_func, ...)`、`timer_setup(&t, my_func, ...)`、`INIT_WORK(&w, my_func)` 等）
2. 根据赋值的目标，推断该回调的执行上下文
3. 检查该回调函数（以及它调用的所有子函数）是否遵守了上下文约束
4. 特别注意：一个辅助函数本身看起来没问题，但如果它既被进程上下文调用又被中断上下文调用，那其中的可睡眠操作就是条件性的 bug

### 2.4 宏背后的真实语义

**是什么：** C 的宏在预处理阶段展开，分析引擎看到的可能是宏名而不是展开后的代码。

```c
#define DEVICE_LOCK(dev)   do { mutex_lock(&(dev)->mtx); } while(0)
#define SAFE_FREE(p)       do { if (p) { kfree(p); (p) = NULL; } } while(0)
#define CHECK_AND_RETURN(cond, err)  if (cond) return (err)
```

这三个宏分别隐藏了：一个锁获取、一个内存释放、一个可能跳过后续清理代码的 return。

**正确的分析思路：**

1. 提取项目中所有 `#define` 宏定义
2. 识别其中包含资源操作、控制流变更（return、goto、break）的宏
3. 在分析调用者代码时，将宏视为其展开后的语义来分析
4. 特别危险的是**隐藏 return 的宏**——调用者不知道这个宏可能导致提前返回，后续的清理代码都会被跳过

### 2.5 结构体字段的跨函数并发访问

**是什么：** 同一个结构体的同一个字段，被多个函数读写。如果某些函数有锁保护而另一些没有，就存在数据竞态。

**为什么难抓：** 需要跨所有文件汇聚"谁在读写这个字段"以及"读写时是否持有锁"。

**正确的分析思路：**

1. 建立索引：对每个 `struct_name->field_name` 的访问，记录（函数、读/写、是否在锁保护下）
2. 如果一个字段在某些函数中有锁保护的写入，但在另一些函数中无锁读写，标记为潜在竞态
3. 注意区分：单线程初始化阶段的无锁访问是安全的；只读访问如果数据本身不会变也是安全的
4. ABBA 死锁：如果函数 X 先锁 A 再锁 B，函数 Y 先锁 B 再锁 A，这是死锁风险

### 2.6 所有权转移 vs 泄漏

**是什么：** 分配了一块内存，然后把指针挂到链表/树/哈希表/框架中。此时所有权已经转移，调用者不应该 free，也不算泄漏。

```c
buf = kmalloc(sizeof(*buf), GFP_KERNEL);
// ... 初始化 buf ...
list_add(&buf->node, &global_list);   // 所有权转移给链表
// 此处不 free(buf) 是正确的！不是泄漏！
```

**为什么难抓：** 浅层分析看到 malloc 没有 free 就报泄漏，但实际上所有权已经转移了。

**正确的分析思路：**

1. 识别所有权转移的模式：list_add、rb_insert、hash_add、赋值给全局/结构体字段、通过返回值传递给调用者、传递给框架注册函数等
2. 如果资源在 free 之前经历了所有权转移，不应报告为泄漏
3. 反过来：如果所有权已经转移了还去 free，那是 bug（double-free 或 use-after-free）
4. 如果 kref_put/Release 返回了"引用计数归零"，之后不能再访问该对象

### 2.7 类型转换和 void* 数据流

**是什么：** C 大量使用 void* 做泛型。指针存进去是类型 A，取出来被当成类型 B 使用，如果 A≠B 就是严重 bug。C++ 的 reinterpret_cast 同理。

**正确的分析思路：**

1. 追踪 void* 字段（如 private_data、user_data、context）的赋值点和使用点
2. 检查同一个 void* 字段是否在不同地方被赋了不同类型的值
3. 检查取出后的强制类型转换是否与存入时的类型一致
4. C++ 中特别关注 reinterpret_cast 和 static_cast 的安全性

### 2.8 初始化和销毁的顺序对称性

**是什么：** 模块/驱动的 init 函数按顺序获取资源 A → B → C，对应的 exit 函数应该按 C → B → A 逆序释放。如果顺序错了，可能在 B 还被 C 依赖时就释放了 B。

**正确的分析思路：**

1. 找到 init/exit（或构造/析构）函数对
2. 提取 init 中资源获取的顺序
3. 提取 exit 中资源释放的顺序
4. 验证是否严格逆序
5. 特别注意：注销回调（如 free_irq、del_timer_sync）必须在释放回调可能引用的资源之前

### 2.9 状态机的完整性

**是什么：** 很多 C 代码通过结构体字段（如 `dev->state`）实现隐式状态机。某些操作只在特定状态下合法。

**正确的分析思路：**

1. 找到所有对状态字段的赋值（`dev->state = XXX`）和检查（`if (dev->state == YYY)`）
2. 构建状态转换图：哪个函数把状态从什么值改成什么值
3. 检查：是否存在不可达的状态？是否存在未处理的状态？
4. 检查：状态检查和状态修改之间是否有并发窗口（TOCTOU）

### 2.10 条件编译的多配置问题

**是什么：** `#ifdef CONFIG_SMP` 下的锁操作在单核配置下可能被编译掉，导致某个配置下有保护另一个配置下裸奔。

**正确的分析思路：**

1. 识别 `#ifdef` / `#if` 保护的代码块中是否包含资源操作或同步原语
2. 分析：如果该条件为假，被保护的操作消失后，代码逻辑是否仍然安全
3. 至少标记出哪些关键操作是条件编译的，让深层分析 AI 关注

### 2.11 整数语义与用户输入边界

**是什么：** 用户传入的整数参与了大小计算，可能导致整数溢出，进而导致分配过小的缓冲区。

```c
size_t len = user_input;        // 用户可控
char *buf = malloc(len + 1);   // 如果 len = SIZE_MAX，len+1 溢出为 0
memcpy(buf, src, len);         // 写入 SIZE_MAX 字节到 0 大小的缓冲区 → 灾难
```

**正确的分析思路：**

1. 标记所有来自用户空间的输入（copy_from_user、ioctl 参数、read/write 参数等）
2. 追踪这些值流向了哪些算术运算和内存分配
3. 检查是否有溢出校验、上界校验
4. 特别关注 `alloc(user_size + constant)` 模式

### 2.12 跨编译单元的全局状态

**是什么：** 全局变量或 static 变量被多个函数甚至多个文件的函数读写，形成隐式耦合。

**正确的分析思路：**

1. 索引所有全局/static 变量的读写点
2. 如果一个全局变量有写入者也有读取者，但没有同步保护，标记为潜在竞态
3. 检查全局状态的初始化时序：是否可能在初始化完成前就被其他代码读取

---

## 第三章 分析引擎的架构应该怎么改

### 3.1 当前架构的问题

```
当前：源码 → 逐函数扫描 → 模式匹配 → 报问题
                 ↑
            只看一个函数，啥上下文都没有
```

### 3.2 改进后的架构

```
改进：源码 → 预处理（构建全局索引） → 组装上下文 → 调用AI深层分析
                    ↓
         ┌──────────────────────────────────────┐
         │  全局索引（在调用 AI 之前构建好）         │
         │                                      │
         │  · 函数调用图（谁调用谁、谁被谁调用）     │
         │  · 每个函数内的资源操作清单              │
         │  · 每个函数内的错误退出点清单            │
         │  · 已确认的配对操作关系                  │
         │  · 回调注册关系（函数指针赋值）           │
         │  · 宏定义展开后的语义                   │
         │  · 结构体字段的跨函数读写索引            │
         │  · 全局变量的跨文件读写索引              │
         │  · 所有权转移点标记                     │
         │  · 状态字段赋值记录                     │
         └──────────────────────────────────────┘
                    ↓
         ┌──────────────────────────────────────┐
         │  调用 AI 做深层分析时，必须附带：         │
         │                                      │
         │  · 当前函数的代码                       │
         │  · 它的调用者和被调用者的代码             │
         │  · 它涉及的资源的完整配对信息             │
         │  · 它涉及的结构体字段的全部其他访问者      │
         │  · 它涉及的回调的上下文约束               │
         │  · 相关的宏定义                         │
         │  · 明确告诉 AI 哪些是已确认的正常模式      │
         └──────────────────────────────────────┘
```

**核心思想：不要让 AI 在没有上下文的情况下分析单个函数。要先用程序化手段构建全局索引，然后把相关上下文一起喂给 AI。**

### 3.3 对调用 AI 的具体要求

当你的分析引擎调用其他 AI 分析某个函数或某个问题时，prompt 中**必须包含**：

1. **调用图上下文**：这个函数被谁调用、它调用了谁。不是全部调用图，而是与当前分析问题相关的那一段。

2. **配对操作的全局视图**：告诉 AI "函数 X 里的 acquire 和函数 Y 里的 release 是一对，不要误报"。

3. **每条执行路径的资源持有状态**：在每个可能的退出点，当前持有哪些资源。这是预处理阶段可以算出来的。

4. **判断准则**：明确告诉 AI 什么是误报、什么不是。比如：
   - devm_* 系列分配不需要手动释放
   - 所有权转移后不 free 是正确的
   - 已确认的跨函数配对不是 bug
   - 回调在原子上下文中不能睡眠
   - init 和 exit 的资源操作应该逆序对称

5. **要求 AI 输出置信度**：对每个发现，AI 应说明它认为这是真 bug 还是可能的误报，以及理由。

---

## 第四章 给深层分析 AI 的 prompt 应该包含什么

当你的引擎调用其他 AI 做具体分析时，不要只把代码甩过去。prompt 的结构应该是：

```
[角色定义]
你是 C/C++ 代码审计专家。你的分析必须超越单函数级别。

[已知信息]
以下是预处理阶段已经确认的信息，你不需要重复发现，也不要把它们当 bug 报告：
- 已确认的配对关系：（列表）
- 已确认的所有权转移：（列表）
- 已确认的回调上下文：（列表）

[待分析的代码]
以下函数存在潜在问题需要深入分析：
（代码 + 调用者代码 + 被调用者代码）

[上下文索引]
- 调用图：（相关部分）
- 该函数涉及的结构体字段，还被以下函数访问：（列表）
- 该函数涉及的宏定义展开：（列表）
- 该函数的每个退出点处的资源持有状态：（列表）

[分析要求]
请按以下维度逐一分析：
1. 每条错误路径是否完整释放了资源
2. 是否有并发访问未保护
3. 是否有类型转换不安全
4. 是否有整数溢出风险
5. ...

[输出要求]
对每个发现，输出：问题类型、位置、完整执行路径、修复方案、误报可能性评估。
```

---

## 第五章 怎么验证分析深度够了

改进后的分析引擎，至少应该能：

1. **不误报跨函数配对**：不要把封装函数里的单侧操作当 bug
2. **能抓错误路径泄漏**：函数获取了 A、B、C，在 B 失败的 goto 路径上忘了释放 A
3. **能抓 early return 泄漏**：持有资源后直接 return 错误码，没走清理
4. **能抓回调上下文违规**：注册为中断处理的函数里调用了 mutex_lock
5. **能识别所有权转移**：malloc 后 list_add 不报泄漏
6. **能发现不一致的锁保护**：同一字段有的函数有锁有的没有
7. **能穿透宏**：宏里藏的 return 导致跳过了后续清理
8. **能检查初始化/销毁对称性**：init 里分配了 A→B→C，exit 里释放了 C→A（漏了 B）
9. **不会被噪音淹没**：输出的问题列表中，真 bug 占主要部分，而不是大量误报里埋着几个真问题

---

## 第六章 优先级建议

如果不能一次全做，按以下优先级迭代：

**P0（最高优先级）：**
- 跨函数配对操作识别（消除最大量的误报）
- 错误路径资源泄漏检查（这是真实 bug 最密集的区域）

**P1：**
- 回调上下文约束检查
- 所有权转移识别
- 宏语义穿透

**P2：**
- 结构体字段并发访问一致性
- 初始化/销毁顺序对称性
- 类型转换安全

**P3：**
- 状态机完整性
- 条件编译多配置问题
- 整数溢出与用户输入边界
- 跨编译单元全局状态
